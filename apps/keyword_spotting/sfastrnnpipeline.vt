using sfastrnn_define;
static unsigned init_error_code = SFASTRNN2P_UNINITIALIZED;
static float [FEAT_BUFFER_LEN] feat_container;
static float [FEAT_BUFFER_LEN] flat_feat_vec;
static float [32] mfcc_result;
FIFOCircularQ featVecQ;
static float [H0_BUFFER_LEN] h0_container;
static SFastRNNParams2 sfastrnn2_params;
static float [H0_LEN] h0_buffer;
static float [H0_BUFFER_LEN] inp1_buffer;
static float [FINAL_H_LEN] final_h;
FCParams_pointer fcparams;
static float [NUM_LABELS] logits;
FIFOCircularQ audioQ;
static int16_t [AUDIO_SAMPLES_BUFFER_LEN] audio_samples_container;
rtos::Mutex audio_buffer_mutex;
rtos::Thread pred_thread;
static int32_t [NFFT] audio_frame_buffer;
static int8_t quit_prediction_flag;
static int16_t preemph_tail;
//size below is NFILT * (NFILT / 2 + 1)
static float32_t [544] fbank_f32;
/*#ifdef FFT_Q31
    static q31_t fbank_q31[NFILT * (NFFT/ 2 + 1)];
#endif*/

unit_16 sfastrnn2p_init(FastRNNParams_pointer p0, FastRNNParams_pointer p1,
                        FCParams_pointer fc){

    uint16_t fcparams_outputDim = get_outputDim(fc);
    uint16_t fcparams_inputDim = get_inputDim(fc);
    uint16_t ret = 0;
    int status;
    uint16_t p0_statesLen = get_statesLen(p0);
    uint16_t p1_timeSteps = get_timeSteps(p1);
    uint16_t p0_timeSteps = get_timeSteps(p0);
    uint16_t p1_statesLen = get_statesLen(p1);
    uint16_t p0_featLen = get_featLen(p0);
    uint_32 size = p0_statesLen * p1_timeSteps;

    if(init_error_code != SFASTRNN2P_UNINITIALIZED){
        return SFASTRNN2P_MULTIPLE_INIT_ERROR;
    }

    ret = initSFastRNN2(&sfastrnn2_params, p0, p1, h0_container,
                        h0_buffer, inp1_buffer);

    if(ret != 0){
        return SFASTRNN2P_SFASTRNN2_INIT_ERR;
    }

    if (size != H0_BUFFER_LEN){
        return SFASTRNN2P_H0_BUFFER_LEN_ERR;
    }

    if (FINAL_H_LEN != p1_statesLen){
        return SFASTRNN2P_FINAL_H_LEN_ERR;
    }

    if (H0_LEN != p0_statesLen){
        return SFASTRNN2P_H0_LEN_ERR;
    }

    if (NUM_LABELS != fcparams_outputDim){
        return SFASTRNN2P_FC_OUT_LEN_ERR;
    }
    if (FINAL_H_LEN != fcparams_inputDim){
        return SFASTRNN2P_FC_IN_LEN_ERR;
    }

    q_init(&audioQ, audio_samples_container, AUDIO_SAMPLES_BUFFER_LEN,
           cb_write_int16, cb_read_int16);

    size = p0_timeSteps * p0_featLen;
    if (size != FEAT_BUFFER_LEN){
        return SFASTRNN2P_FEAT_BUFFER_LEN_ERR;
    }
    q_init(&featVecQ, feat_container, FEAT_BUFFER_LEN,
           cb_write_float, cb_read_float);

    get_filterbank_parameters(fbank_f32, 32, SAMPLING_RATE, 512);

    /*#ifdef FFT_Q31
        arm_float_to_q31(fbank_f32, fbank_q31, 32 * (512/2 + 1));
    #endif*/

    if(NFFT < FRAME_LEN){
        return SFASTRNN2P_NFFT_TOO_SMALL_ERR;
    }
    //size_of(unit32_t) is 4
    memset(audio_frame_buffer, 0, 512 * 4);

    status = pred_thread.start(pred_func);
    if (status != 0){
        return SFASTRNN2P_PRED_THR_SPWAN_ERR;
    }
    quit_prediction_flag = 0;
    preemph_tail = 0;

    prediction_cb = pred_cb_pointer;
    return SFASTRNN2P_SUCCESS;
}