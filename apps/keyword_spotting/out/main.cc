/********************************************************************************
This code is automatically generated by the VerticalThings compiler. DO NOT EDIT!
********************************************************************************/

struct _arec_event {volatile int _state;};
#define NULL ((void *)0UL)
struct _future {void *_parec; int (*_pfn)(void *, void *);}; 
#include "/home/sharingan/Desktop/Work/Vertical_Things_Project/EdgeML/Applications/KeywordSpotting/MXChip-SRNN/src/lib/utils/circularq.h"
#include "/home/sharingan/Desktop/Work/Vertical_Things_Project/EdgeML/Applications/KeywordSpotting/MXChip-SRNN/src/models/model.h"
#include "/home/sharingan/Desktop/Work/Vertical_Things_Project/EdgeML/Applications/KeywordSpotting/MXChip-SRNN/src/lib/sfastrnn_pipeline/sfastrnnpipeline.h"
#include "inc/hot_fixes.h"
#include "/home/sharingan/Desktop/Work/Vertical_Things_Project/devkit-mbedos5-getstarted/libraries/devkit-sdk/AZ3166/src/libraries/AudioV2/src/AudioClassV2.h"
#include "/home/sharingan/Desktop/Work/Vertical_Things_Project/devkit-mbedos5-getstarted/libraries/devkit-sdk/AZ3166/src/cores/arduino/Arduino.h"
#include "/home/sharingan/Desktop/Work/Vertical_Things_Project/devkit-mbedos5-getstarted/mbed-os/platform/mbed_wait_api.h"
struct _arec__main_recordCallback;
typedef void (*_t__main_recordCallback) ();
struct _arec__main_init_record;
typedef void (*_t__main_init_record) ();
struct _arec__main_start_record;
typedef void (*_t__main_start_record) ();
struct _arec__main_prediction_callback;
typedef void (*_t__main_prediction_callback) (float_pointer main_prediction_callback_vec, int main_prediction_callback_len);
struct _arec__main_setup;
typedef void (*_t__main_setup) ();
struct _arec__main_loop;
typedef void (*_t__main_loop) ();
struct _arec__main_printStr;
typedef void (*_t__main_printStr) (char_pointer main_printStr_a);
struct _arec__main_main;
typedef void (*_t__main_main) (struct _arec__main_main* _this, void*  _ret0);
struct _arec__main_main{
    int _state = 0;
};
/*Module vars for main*/
FastRNNParams main_fastrnnParams0;
FastRNNParams main_fastrnnParams1;
FCParams main_fcParams;
const_char_arr main_labelInvArr[13]={ "Noise", "go", "no", "on", "up", "bed", "cat", "dog", "off", "one", "six", "two", "yes"} ;
int main_VOTE_WIN_LEN=10;
int main_VOTE_MAJORITY=5;
int main_NUM_LABELS=13;
FIFOCircularQ main_votingQ;
static int main_votingContainer[10];
static int main_votingFrequence[13];
int main_TRANSFER_BUFFER_MAX_LEN=128;
static AudioClass& main_Audio=AudioClass::getInstance() ;
int main_AUDIO_CHUNK_SIZE=512;
char main_readBuffer[512];
static int main_transfer_buffer_curr_len=0;
static int16_t main_transfer_buffer[128];
/*End of module vars for main*/
void _main_recordCallback()
{
    int main_recordCallback_length=main_Audio.readFromRecordBuffer(main_readBuffer, main_AUDIO_CHUNK_SIZE) ;
    int main_recordCallback_i=0;
    {
        main_recordCallback_length=(main_recordCallback_length/2);
        main_recordCallback_length=(main_recordCallback_length-(main_recordCallback_length%2));
        main_recordCallback_length=(main_recordCallback_length/2);
        if((main_recordCallback_length>main_TRANSFER_BUFFER_MAX_LEN))
        {
            error("Transfer buffer too small") ;
        }
        if((main_transfer_buffer_curr_len!=0))
        {
            Serial.printf("Error: Transfer buffer not empty. %d dropped\n", main_recordCallback_length) ;
        }
        else
        {
            while((main_recordCallback_i<main_recordCallback_length))
            {
                get_element(main_readBuffer, (2*main_recordCallback_i)) ;
                main_recordCallback_i=(main_recordCallback_i+1);
            }
            main_transfer_buffer_curr_len=main_recordCallback_length;
        }
    }
}
void _main_init_record()
{
    {
        main_Audio.format(16000, 16) ;
    }
}
void _main_start_record()
{
    {
        main_Audio.startRecord(main_recordCallback) ;
    }
}
void _main_prediction_callback(float_pointer main_prediction_callback_vec, int main_prediction_callback_len)
{
    int main_prediction_callback_arg=argmax(main_prediction_callback_vec, main_prediction_callback_len) ;
    int main_prediction_callback_oldarg=to_int(&(main_votingQ)) ;
    char main_prediction_callback_str[20];
    {
        if(((main_prediction_callback_oldarg>=main_NUM_LABELS)||(main_prediction_callback_oldarg<0)))
        {
            main_prediction_callback_oldarg=0;
        }
        main_votingFrequence[main_prediction_callback_arg]=(main_votingFrequence[main_prediction_callback_arg]+1);
        main_votingFrequence[main_prediction_callback_oldarg]=(main_votingFrequence[main_prediction_callback_oldarg]-1);
        q_force_enqueue(&(main_votingQ), &(main_prediction_callback_arg)) ;
        if((main_votingFrequence[main_prediction_callback_arg]>=main_VOTE_MAJORITY))
        {
            sprintf(main_prediction_callback_str, "Pred: %s (%d)", main_labelInvArr[main_prediction_callback_arg], main_prediction_callback_arg) ;
            Screen.print(main_prediction_callback_str, false) ;
        }
    }
}
void _main_setup()
{
    uint16_t main_setup_ret;
    {
        q_init(&(main_votingQ), main_votingContainer, main_VOTE_WIN_LEN, cb_write_int, cb_read_int) ;
        main_votingFrequence[0]=5;
        Serial.begin(115200) ;
        Screen.init() ;
        delay(500) ;
        initFastRNN0() ;
        initFastRNN1() ;
        initFC() ;
        delay(500) ;
        Screen.clean() ;
        sfastrnn2p_init(&(main_fastrnnParams0), &(main_fastrnnParams1), &(main_fcParams), main_prediction_callback) ;
        Serial.printf("Return code: %d (init)\n", main_setup_ret) ;
        if((main_setup_ret!=0))
        {
            error("Shallow FastRNN initialization failed (code %d)", main_setup_ret) ;
        }
        if((main_setup_ret!=0))
        {
            while(1)
            {
            }
        }
        _main_init_record() ;
        delay(500) ;
        Serial.println() ;
        Serial.println("Ready") ;
        Screen.print(0, "Ready") ;
        delay(500) ;
        _main_start_record() ;
    }
}
void _main_loop()
{
    uint16_t main_loop_ret;
    static int main_loop_count;
    {
        while(1)
        {
            if((main_transfer_buffer_curr_len==0))
            {
            }
            else
            {
                sfastrnn2p_add_new_samples(main_transfer_buffer, main_transfer_buffer_curr_len) ;
                if((main_loop_ret!=0))
                {
                    Serial.printf("Error pushing to interface %d\n", main_loop_ret) ;
                }
                main_loop_count=0;
                main_loop_count=(main_loop_count+main_transfer_buffer_curr_len);
                if(((main_loop_count%128000)==0))
                {
                    Serial.printf("Pushed %d seconds\n", (main_loop_count/16000)) ;
                }
                main_transfer_buffer_curr_len=0;
            }
        }
    }
}
void _main_printStr(char_pointer main_printStr_a)
{
    {
        Serial.println(main_printStr_a) ;
    }
}
int _main_main(struct _arec__main_main* _this)
{
static const void * _atbl[] = { &&lstate_0 };
int _state = _this->_state;
_this->_state = 0;
if (_state > 0 && _state <= 0) goto *(_atbl[_state]);
 lstate_0:
{
    _main_setup() ;
    _main_loop() ;
}
return _this->_state;
}
/*Entry point - the 'C' main function*/
struct _arec__main_main _arec_main;
int main(){
    int status = -1;
    while (status != 0){
        status = _main_main(&_arec_main);
    }
    while (true);
    return 0;
}